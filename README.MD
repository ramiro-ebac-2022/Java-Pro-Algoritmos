<p align="center">
<img 
    src="./assets/Podcast_ML_Cover.jpg"
    width="300"
/>
</p>

# 1.7 - Calculando a efici√™ncia em Algoritmos.

Este √© um artigo criado para o curso **Profiss√£o : Especialista Back-End JAVA** da escola **EBAC** (Parte 3 "Back-End Java Pro" - Cap√≠tulo 2 "Algoritmos").

 > üíª **Complexidade Assint√≥tica de Tempo e de Espa√ßo** 
 A complexidade assint√≥tica √© uma maneira de descrever a efici√™ncia de um algoritmo em termos de tempo de execu√ß√£o (complexidade de tempo) e uso de mem√≥ria (complexidade de espa√ßo), √† medida que o tamanho da entrada cresce. Ela ajuda a entender como um algoritmo se comporta em termos de desempenho √† medida que a entrada aumenta, ignorando constantes e termos de menor ordem. 
 > A an√°lise da complexidade assint√≥tica √© crucial porque:
>- Compara√ß√£o de Algoritmos: Permite comparar diferentes algoritmos e escolher o mais eficiente.
>- Escalabilidade: Ajuda a prever como um algoritmo se comportar√° com entradas grandes.
>- Otimiza√ß√£o: Identifica pontos fracos em termos de tempo ou espa√ßo, ajudando na otimiza√ß√£o do algoritmo.
>
 > üíª **Complexidade de Tempo** 
 Complexidade de tempo refere-se ao tempo que um algoritmo leva para executar em rela√ß√£o ao tamanho da entrada. Ela √© expressa em termos da nota√ß√£o Big O (O(n)), onde n representa o tamanho da entrada.
>- O(1): Tempo constante. O tempo de execu√ß√£o n√£o depende do tamanho da entrada.
>- O(n): Tempo linear. O tempo de execu√ß√£o cresce linearmente com o tamanho da entrada.
>- O(n^2): Tempo quadr√°tico. O tempo de execu√ß√£o cresce quadraticamente com o tamanho da entrada.
>- O(log n): Tempo logar√≠tmico. O tempo de execu√ß√£o cresce logaritimicamente com o tamanho da entrada. 
>
> üíª **Complexidade de Espa√ßo** 
>Complexidade de espa√ßo refere-se √† quantidade de mem√≥ria que um algoritmo usa em rela√ß√£o ao tamanho da entrada. Ela tamb√©m √© expressa em termos da nota√ß√£o Big O.
>- O(1): Espa√ßo constante. A quantidade de mem√≥ria usada n√£o depende do tamanho da entrada.
>- O(n): Espa√ßo linear. A quantidade de mem√≥ria usada cresce linearmente com o tamanho da entrada.
>- O(n^2): Espa√ßo quadr√°tico. A quantidade de mem√≥ria usada cresce quadraticamente com o tamanho da entrada.
 


## ‚ú® Exemplos pr√°ticos
Seguem exemplos onde aplicamos o an√°lise da complexidade assint√≥tica, nos seguintes algoritmos : 

- [Pilha](https://pt.wikipedia.org/wiki/Pilha_(inform%C3%A1tica))
- [Fila FIFO](https://pt.wikipedia.org/wiki/FIFO)
- [Lista Encadeada](https://pt.wikipedia.org/wiki/Lista_ligada)
- [Mapa de Hash](https://joaoarthurbm.github.io/eda/posts/hashtable/)



## üõ†Ô∏è Pilha

Implementa√ß√£o de uma classe que representa uma estrutura tipo Pilha. Aceita somente inteiros. Inclui os seguintes m√©todos : 

- ü§ñ Push(). Coloca um inteiro no topo da pilha.
- ü§ñ pop(): Remove o valor do topo da pilha e o retorna ao chamador.
- ü§ñ top(): Espia o inteiro que est√° no topo e o retorna sem mexer na pilha.
- ü§ñ isEmpty(): Retorna true ou false dependendo da pilha estar vazia ou n√£o.
- ü§ñ size(): Retorna um valor inteiro com o n√∫mero de elementos da pilha.

```java
public class CustomStack {
    private Node top;
    private int size;

    // Classe interna para representar um n√≥ na pilha
    private class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
        }
    }

    // Construtor da pilha
    public CustomStack() {
        top = null;
        size = 0;
    }

    // M√©todo para colocar um inteiro no topo da pilha
    public void push(int value) {
        Node newNode = new Node(value);
        newNode.next = top;
        top = newNode;
        size++;
    }

    // M√©todo para remover e retornar o valor do topo da pilha
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("Pilha vazia, n√£o √© poss√≠vel remover elementos.");
        }
        int value = top.value;
        top = top.next;
        size--;
        return value;
    }

    // M√©todo para espirar o valor do topo da pilha sem remov√™-lo
    public int top() {
        if (isEmpty()) {
            throw new RuntimeException("Pilha vazia, n√£o √© poss√≠vel espirar elementos.");
        }
        return top.value;
    }

    // M√©todo para verificar se a pilha est√° vazia
    public boolean isEmpty() {
        return top == null;
    }

    // M√©todo para retornar o n√∫mero de elementos na pilha
    public int size() {
        return size;
    }

    public static void main(String[] args) {
        CustomStack stack = new CustomStack();

        stack.push(10);
        stack.push(20);
        stack.push(30);

        System.out.println("Top element: " + stack.top()); // 30
        System.out.println("Stack size: " + stack.size()); // 3

        System.out.println("Popped element: " + stack.pop()); // 30
        System.out.println("Top element after pop: " + stack.top()); // 20
        System.out.println("Stack size after pop: " + stack.size()); // 2

        System.out.println("Is stack empty? " + stack.isEmpty()); // false

        stack.pop();
        stack.pop();

        System.out.println("Is stack empty after popping all elements? " + stack.isEmpty()); // true
    }
}

```

#### Explica√ß√£o.
- [X] Classe CustomStack: A classe principal que representa a pilha.
- [X] Classe interna Node: Representa um n√≥ na pilha, contendo um valor inteiro e uma refer√™ncia para o pr√≥ximo n√≥.
- [X] Construtor CustomStack: Inicializa a pilha com top como null e size como 0.
- [X] M√©todo push(int value): Adiciona um novo valor ao topo da pilha.
- [X] M√©todo pop(): Remove e retorna o valor do topo da pilha, lan√ßando uma exce√ß√£o se a pilha estiver vazia.
- [X] M√©todo top(): Retorna o valor do topo da pilha sem remov√™-lo, lan√ßando uma exce√ß√£o se a pilha estiver vazia.
- [X] M√©todo isEmpty(): Verifica se a pilha est√° vazia.
- [X] M√©todo size(): Retorna o n√∫mero de elementos na pilha.
- [X] O m√©todo main fornece um exemplo de como usar a classe CustomStack.

#### Complexidade Assint√≥tica de Tempo e Espa√ßo.
<p align="center">
<img 
    src="./assets/complexidade_customstack.png"
    width="800"
/>
</p> 


## üõ†Ô∏è Fila Fifo

Implementa√ß√£o de uma classe que representa uma estrutura tipo Fila FIFO. Aceita somente inteiros. Inclui os seguintes m√©todos : 

- ü§ñ Enqueue(). Adiciona um inteiro √† fila.
- ü§ñ Dequeue(): Remove um inteiro da fila.
- ü§ñ Rear(): Retorna o inteiro que est√° no fim da fila.
- ü§ñ Front(): Retorna o inteiro que est√° na frente da fila.
- ü§ñ Size(): Retorna o tamanho da fila.
- ü§ñ IsEmpty(): Retorna True ou False dependendo da fila estar vazia ou n√£o.

```java
public class CustomQueue {
    private Node front;
    private Node rear;
    private int size;

    // Classe interna para representar um n√≥ na fila
    private class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
        }
    }

    // Construtor da fila
    public CustomQueue() {
        front = null;
        rear = null;
        size = 0;
    }

    // M√©todo para adicionar um inteiro √† fila
    public void enqueue(int value) {
        Node newNode = new Node(value);
        if (isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            rear.next = newNode;
            rear = newNode;
        }
        size++;
    }

    // M√©todo para remover e retornar o inteiro da frente da fila
    public int dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("Fila vazia, n√£o √© poss√≠vel remover elementos.");
        }
        int value = front.value;
        front = front.next;
        if (front == null) {
            rear = null;
        }
        size--;
        return value;
    }

    // M√©todo para retornar o inteiro que est√° no fim da fila
    public int last() {
        if (isEmpty()) {
            throw new RuntimeException("Fila vazia, n√£o √© poss√≠vel obter o √∫ltimo elemento.");
        }
        return rear.value;
    }

    // M√©todo para retornar o inteiro que est√° na frente da fila
    public int front() {
        if (isEmpty()) {
            throw new RuntimeException("Fila vazia, n√£o √© poss√≠vel obter o primeiro elemento.");
        }
        return front.value;
    }

    // M√©todo para retornar o tamanho da fila
    public int size() {
        return size;
    }

    // M√©todo para verificar se a fila est√° vazia
    public boolean isEmpty() {
        return front == null;
    }

    public static void main(String[] args) {
        CustomQueue queue = new CustomQueue();

        queue.enqueue(10);
        queue.enqueue(20);
        queue.enqueue(30);

        System.out.println("Front element: " + queue.front()); // 10
        System.out.println("Last element: " + queue.last()); // 30
        System.out.println("Queue size: " + queue.size()); // 3

        System.out.println("Dequeued element: " + queue.dequeue()); // 10
        System.out.println("Front element after dequeue: " + queue.front()); // 20
        System.out.println("Queue size after dequeue: " + queue.size()); // 2

        System.out.println("Is queue empty? " + queue.isEmpty()); // false

        queue.dequeue();
        queue.dequeue();

        System.out.println("Is queue empty after dequeuing all elements? " + queue.isEmpty()); // true
    }
}

```

#### Explica√ß√£o.
- [X] Classe CustomQueue: A classe principal que representa a fila.
- [X] Classe interna Node: Representa um n√≥ na fila, contendo um valor inteiro e uma refer√™ncia para o pr√≥ximo n√≥.
- [X] Construtor CustomQueue: Inicializa a fila com front e rear como null e size como 0.
- [X] M√©todo enqueue(int value): Adiciona um novo valor ao fim da fila.
- [X] M√©todo dequeue(): Remove e retorna o valor da frente da fila, lan√ßando uma exce√ß√£o se a fila estiver vazia.
- [X] M√©todo last(): Retorna o valor do fim da fila, lan√ßando uma exce√ß√£o se a fila estiver vazia.
- [X] M√©todo front(): Retorna o valor da frente da fila, lan√ßando uma exce√ß√£o se a fila estiver vazia.
- [X] M√©todo size(): Retorna o n√∫mero de elementos na fila.
- [X] M√©todo isEmpty(): Verifica se a fila est√° vazia.
- [X] O m√©todo main fornece um exemplo de como usar a classe CustomQueue.

#### Complexidade Assint√≥tica de Tempo e Espa√ßo.
<p align="center">
<img 
    src="./assets/complexidade_customqueue.png"
    width="800"
/>
</p> 



## üõ†Ô∏è Lista encadeada

Implementa√ß√£o de uma classe que representa uma estrutura tipo Lista Encadeada. Aceita somente inteiros. Inclui os seguintes m√©todos : 

- ü§ñ Push(). Adiciona o n√≥ ao fim da lista.
- ü§ñ Pop(): Remove o n√≥ no fim da lista e retorna o mesmo.
- ü§ñ Insert(): Adiciona um n√≥ na posi√ß√£o da lista indicada via par√¢metro.
- ü§ñ Remove(): Remove um n√≥ na posi√ß√£o da lista indicada via par√¢metro.
- ü§ñ ElementAt(): Retorna o elemento que est√° no √≠ndice da lista indicada via par√¢metro.
- ü§ñ Size(): Retorna o tamanho da lista.
- ü§ñ PrintList(): Retorna uma representa√ß√£o em texto da lista.

```java
public class CustomLinkedList {
    private Node head;
    private int size;

    // Classe interna para representar um n√≥ na lista
    public static class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    // Construtor da lista encadeada
    public CustomLinkedList() {
        head = null;
        size = 0;
    }

    // M√©todo para adicionar um n√≥ ao fim da lista
    public void push(Node node) {
        if (head == null) {
            head = node;
        } else {
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = node;
        }
        size++;
    }

    // M√©todo para remover e retornar o n√≥ no fim da lista
    public Node pop() {
        if (head == null) {
            throw new RuntimeException("Lista vazia, n√£o √© poss√≠vel remover elementos.");
        }

        if (head.next == null) {
            Node node = head;
            head = null;
            size--;
            return node;
        }

        Node current = head;
        while (current.next.next != null) {
            current = current.next;
        }
        Node node = current.next;
        current.next = null;
        size--;
        return node;
    }

    // M√©todo para adicionar um n√≥ na posi√ß√£o indicada
    public void insert(int index, Node node) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("√çndice fora dos limites.");
        }

        if (index == 0) {
            node.next = head;
            head = node;
        } else {
            Node current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current.next;
            }
            node.next = current.next;
            current.next = node;
        }
        size++;
    }

    // M√©todo para remover um n√≥ na posi√ß√£o indicada
    public void remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("√çndice fora dos limites.");
        }

        if (index == 0) {
            head = head.next;
        } else {
            Node current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current.next;
            }
            current.next = current.next.next;
        }
        size--;
    }

    // M√©todo para retornar o n√≥ na posi√ß√£o indicada
    public Node elementAt(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("√çndice fora dos limites.");
        }

        Node current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
        return current;
    }

    // M√©todo para retornar o tamanho da lista
    public int size() {
        return size;
    }

    // M√©todo para retornar uma representa√ß√£o em texto da lista
    public void printList() {
        Node current = head;
        while (current != null) {
            System.out.print(current.value + " -> ");
            current = current.next;
        }
        System.out.println("null");
    }

    public static void main(String[] args) {
        CustomLinkedList list = new CustomLinkedList();

        list.push(new Node(10));
        list.push(new Node(20));
        list.push(new Node(30));

        System.out.println("Lista inicial:");
        list.printList(); // 10 -> 20 -> 30 -> null

        list.insert(1, new Node(15));
        System.out.println("Depois de inserir 15 na posi√ß√£o 1:");
        list.printList(); // 10 -> 15 -> 20 -> 30 -> null

        list.remove(2);
        System.out.println("Depois de remover o elemento na posi√ß√£o 2:");
        list.printList(); // 10 -> 15 -> 30 -> null

        System.out.println("Elemento na posi√ß√£o 1: " + list.elementAt(1).value); // 15
        System.out.println("Tamanho da lista: " + list.size()); // 3

        System.out.println("Elemento removido do final: " + list.pop().value); // 30
        System.out.println("Lista depois de remover o √∫ltimo elemento:");
        list.printList(); // 10 -> 15 -> null
    }
}

```

#### Explica√ß√£o.
- [X] Classe CustomLinkedList: A classe principal que representa a lista encadeada.
- [X] Classe interna Node: Representa um n√≥ na lista, contendo um valor inteiro e uma refer√™ncia para o pr√≥ximo n√≥.
- [X] Construtor CustomLinkedList: Inicializa a lista encadeada com head como null e size como 0.
- [X] M√©todo push(Node node): Adiciona um novo n√≥ ao fim da lista.
- [X] M√©todo pop(): Remove e retorna o n√≥ no fim da lista, lan√ßando uma exce√ß√£o se a lista estiver vazia.
- [X] M√©todo insert(int index, Node node): Adiciona um n√≥ na posi√ß√£o indicada na lista.
- [X] M√©todo remove(int index): Remove o n√≥ na posi√ß√£o indicada na lista, lan√ßando uma exce√ß√£o se o √≠ndice estiver fora dos limites.
- [X] M√©todo elementAt(int index): Retorna o n√≥ na posi√ß√£o indicada na lista, lan√ßando uma exce√ß√£o se o √≠ndice estiver fora dos limites.
- [X] M√©todo size(): Retorna o n√∫mero de elementos na lista.
- [X] M√©todo printList(): Imprime uma representa√ß√£o textual da lista.

#### Complexidade Assint√≥tica de Tempo e Espa√ßo.
<p align="center">
<img 
    src="./assets/complexidade_customlinkedlist.png"
    width="800"
/>
</p> 



## üõ†Ô∏è Mapa de Hash

Implementa√ß√£o de uma classe que representa uma estrutura tipo Mapa de Hash. Aceita somente inteiros (chave,valor) e ter√° tamanho fixo de 10 elementos. Inclui os seguintes m√©todos : 

- ü§ñ Put(). Adiciona o par (chave,valor) ao mapa.
- ü§ñ Delete(): Remove o valor do topo da pilha e o retorna ao chamador.
- ü§ñ Get(): Retorna o valor associado √† chave passada via par√¢metro.
- ü§ñ Clear(): Remove todos os elementos do mapa.

```java
public class CustomHashMap {
    private static final int SIZE = 10;
    private Entry[] table;

    public CustomHashMap() {
        table = new Entry[SIZE];
    }

    // Classe interna para representar uma entrada no mapa
    private static class Entry {
        int key;
        int value;
        Entry next;

        Entry(int key, int value) {
            this.key = key;
            this.value = value;
            this.next = null;
        }
    }

    // M√©todo para adicionar um par chave/valor ao mapa
    public void put(int key, int value) {
        int index = hash(key);
        Entry newEntry = new Entry(key, value);
        
        if (table[index] == null) {
            table[index] = newEntry;
        } else {
            Entry current = table[index];
            Entry prev = null;
            while (current != null) {
                if (current.key == key) {
                    current.value = value;
                    return;
                }
                prev = current;
                current = current.next;
            }
            prev.next = newEntry;
        }
    }

    // M√©todo para remover um par chave/valor do mapa
    public int delete(int key) {
        int index = hash(key);
        Entry current = table[index];
        Entry prev = null;

        while (current != null) {
            if (current.key == key) {
                if (prev == null) {
                    table[index] = current.next;
                } else {
                    prev.next = current.next;
                }
                return current.value;
            }
            prev = current;
            current = current.next;
        }

        throw new RuntimeException("Chave n√£o encontrada: " + key);
    }

    // M√©todo para obter o valor associado a uma chave
    public int get(int key) {
        int index = hash(key);
        Entry current = table[index];

        while (current != null) {
            if (current.key == key) {
                return current.value;
            }
            current = current.next;
        }

        throw new RuntimeException("Chave n√£o encontrada: " + key);
    }

    // M√©todo para remover todos os elementos do mapa
    public void clear() {
        table = new Entry[SIZE];
    }

    // Fun√ß√£o hash simples
    private int hash(int key) {
        return key % SIZE;
    }

    public static void main(String[] args) {
        CustomHashMap map = new CustomHashMap();

        map.put(1, 100);
        map.put(2, 200);
        map.put(12, 1200); // Colis√£o com a chave 2

        System.out.println("Valor da chave 1: " + map.get(1)); // 100
        System.out.println("Valor da chave 2: " + map.get(2)); // 200
        System.out.println("Valor da chave 12: " + map.get(12)); // 1200

        map.delete(2);
        System.out.println("Valor da chave 12 ap√≥s deletar chave 2: " + map.get(12)); // 1200

        map.clear();
        try {
            System.out.println("Valor da chave 1 ap√≥s clear: " + map.get(1)); // Deve lan√ßar exce√ß√£o
        } catch (RuntimeException e) {
            System.out.println(e.getMessage()); // Chave n√£o encontrada: 1
        }
    }
}

```

#### Explica√ß√£o.
- [X] Classe CustomHashMap: A classe principal que representa o mapa de hash.
- [X] Classe interna Entry: Representa um par chave/valor no mapa, incluindo uma refer√™ncia para o pr√≥ximo Entry na lista encadeada (para tratar colis√µes).
- [X] Construtor CustomHashMap: Inicializa a tabela de hash com um tamanho fixo de 10 elementos.
- [X] M√©todo put(int key, int value): Adiciona um novo par chave/valor ao mapa. Se a chave j√° existir, atualiza o valor associado.
- [X] M√©todo delete(int key): Remove o par chave/valor do mapa e retorna o valor associado √† chave removida.
- [X] M√©todo get(int key): Retorna o valor associado √† chave passada como par√¢metro.
- [X] M√©todo clear(): Remove todos os elementos do mapa, redefinindo a tabela de hash.
- [X] Fun√ß√£o hash(int key): Fun√ß√£o hash simples que calcula o √≠ndice a partir da chave usando a opera√ß√£o m√≥dulo (key % SIZE).

#### Complexidade Assint√≥tica de Tempo e Espa√ßo.
<p align="center">
<img 
    src="./assets/complexidade_customhashmap.png"
    width="800"
/>
</p> 



## üë®‚Äçüíª Autor

<p>
    <img 
      align=left 
      margin=10 
      width=80 
      src="./assets/Avatar_Ramiro.jpeg"
    />
    <p>&nbsp&nbsp&nbspRamiro Zavala<br>
    &nbsp&nbsp&nbsp
    <a 
        href="https://github.com/ramiro-ebac-2022/">
        GitHub
    </a>
    &nbsp;|&nbsp;
    <a 
        href="https://www.linkedin.com/in/ramiro-arce/">
        LinkedIn
    </a>
    &nbsp;|&nbsp;
</p>
</p>
<br/><br/>
<p>

---
